# 哈希表
## 哈希冲突的解决方法
### 开放寻址法：线性探测、二次探测、双重散列
- 线性探测：
		当哈希冲突发生时，线性探测法会逐个探测下一个位置，直到找到空位
		查找时，如果发现当前位置不是目标元素，就会继续往下找，直到找到目标元素或者遇到空位
        删除时，不能直接删除，而是标记为删除，查找时遇到标记为删除的元素，继续往下找
- 二次探测：
        线性探测每次探测的步长是1，二次探测每次探测的步长是平方数
- 双重散列：
        当哈希冲突发生时，通过使用多个哈希函数计算出一个新的位置，直到找到空位
### 链表法
- 散列值相同的元素会放到相同槽位对应的链表中

## 装载因子
装载因子 = 填入表中的元素个数 / 散列表的长度

哈希表的查询效率不能简单说成O(1)，因为会有哈希冲突的情况

## 如何设计工业级的哈希表
### 哈希函数的设计
- 不能太复杂（计算时间耗时）
- 生成的值随机均匀分布

### 装载因子过大怎么办
- rehash，渐进式扩容
- 如果太小也可以做缩容操作，具体看能不能接受内存消耗

### 如何选择冲突解决方法
#### 开放寻址法
- 优点：
    - 数据存在数组中，有效利用cpu缓存加速查询速度
    - 序列化简单
- 缺点
    - 删除操作麻烦，使用标记删除法
    - 所有的数据都存在一个数组中，哈希冲突代价更高
场景： 当数据量比较小，装载因子比较小时，适合采用开放寻址法
#### 链表法
- 优点：
    - 内存利用率更高
    - 支持大装载因子
    - 链表可以改造成更高效的数据结构，比如跳表、红黑树
- 缺点
    - cpu缓存不友好
    - 存储小对象时，指针占用的内存会有一定影响
场景：适合存储大数据量、大对象


##总结
- 如何设计哈希函数
- 如何根据装载因子进行动态扩容
- 如何解决哈希冲突